from pwn import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad


def xor(a, b):
    return bytes(x ^ y for x, y in zip(a, b))


def encrypt(r, msg):
    r.sendlineafter(b"> (hex) ", msg.hex().encode())  # Send input as hex
    r.recvuntil(b"Here is your encryption:\n|\n|   ")
    return bytes.fromhex(r.recvline().strip().decode())

def enc_oracle(r, msg):
    return encrypt(r, msg)[AES.block_size:2*AES.block_size]

def dec_oracle(r, msg, j = 3):
    zero = enc_oracle(r, b"\x00"*AES.block_size)
    x2 = b"\x00" * AES.block_size
    x3 = b"\x00" * AES.block_size
    pt = xor(msg, zero) + x2 + x3

    ct = encrypt(r, pt)[j*AES.block_size:(j+1)*AES.block_size]
    plaintext = xor(ct, zero)

    return plaintext

def decrypt(r, x, y, ct):
    enc_x = enc_oracle(r, x)
    dec = dec_oracle(r, xor(enc_x, y))
    return dec_oracle(r, xor(xor(dec, x), ct))

def main():
    local = True
    host = "confusion.challs.srdnlen.it"
    port = 1338
    recovered_flag = b""
    if local:
        r = process(['./chall.py'])
    else:
        r = remote(host, port)

    info(r.recvuntil("flag = "))
    flag = bytes.fromhex(r.recvline().strip(b"\n").decode())
    info(f"flag: {flag}")

    f1 = dec_oracle(r, flag[1*AES.block_size:2*AES.block_size])
    print(f"f1: {f1}")
    recovered_flag += f1
    flag_parts = [flag[0:AES.block_size], f1]

    print(f"len: {len(flag)//AES.block_size}")
    for i in range(len(flag)//AES.block_size -2):
        f = decrypt(r, flag_parts[i+1], flag_parts[i], flag[(i+2)*AES.block_size: (i+3)*AES.block_size])
        flag_parts.append(f)
        recovered_flag += f

    print(f"recovered_flag: {unpad(recovered_flag, AES.block_size)}")


if __name__ == "__main__":
    main()
